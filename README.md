# hw05_final
Данный проект представляет из себя сайт в котором авторизованный пользователь может создавать посты, добавлять к ним картинку, подписываться на других авторов, комментировать записи.

### Основная текущая проблема проекта.
При запуске проекта через docker-compose up из-за проблемы с ubuntu порт, к которому отзывается сервис (например 8000 или любой другой если его поменять настройках вызова сервера проекта http://192.168.66.2) появляется ошибка 500, связанная с тем что указанный порт занимает другой сервис. Отключение сервиса от порта не помогло, сперва к этому порту прикреплен сервис gunicorn, затем за этим портом, после выполнения ```sudo kill -9 <PID сервиса вызываемого порта>``` данный порт занимает сервис docker-proxy и ошибка повторяется.

## Установка проекта

склонируйте репозиторий в рабочую директорию:
```
git clone https://github.com/RustamIR/hw05_final.git
```
Выполните следующую команду, чтобы обновить все текущие пакеты linux:
```
sudo apt update && sudo apt upgrade
```
Далее можно запускать установку нужной версии Python и пакетов для неё:
```
sudo apt install python3.9 -y
sudo apt install python3.9-venv
```
Установите в виртуальное окрежение для работы с проектом:
```
python3 -m venv venv
```
Активируйте виртуальное окружение:
```
source venv/bin/activate
```
или, если виртуальное окружение находиться в нутри проекта:
```
. venv/bin/activate
```
Для деактивации виртуального окружения используйте следующую команду:
```
deactivate
```
Устновите все необходимые пакеты для работы проекта указанные в текстовом документе requirements:
```
python -m pip install -r requirements.txt 
```

## Настройка сервиса Gunicorn
установите пакет gunicorn

На своём сервере перейдите в директорию с проектом Yatube, активируйте виртуальное окружение и установите пакет gunicorn:
```
pip install gunicorn 
```
В директории /etc/systemd/system/ создайте файл gunicorn.service и откройте его в nano. Для создания файла в системной папке нужны права администратора, их даёт команда sudo:
```
sudo nano /etc/systemd/system/gunicorn.service 
```

Следуюет указать следующую конфигурацию для gunicorn:
```
[Unit]
Description=gunicorn daemon 


After=network.target 

[Service]
# от чьего имени запускать процесс:
# укажите имя, под которым вы подключались к серверу
User=<имя-пользователя-в-системе>

# адрес к директории, где установлен Gunicorn
WorkingDirectory=/home/<имя-пользователя-в-системе>/
<директория-с-проектом-yatube>/<директория-с-файлом-manage.py>/ 

# команду, которую вы запускали руками, теперь будет запускать systemd:
# в указанной директории будет выполнена команда bind
# и по запросу к 127.0.0.1:8000 будет выполнен файл запуска приложения yatube.wsgi
ExecStart=/home/<имя-пользователя-в-системе>/
<директория-с-проектом-yatube>/<путь-до-gunicorn-в-виртуальном-окружении> --bind 127.0.0.1:8000 yatube.wsgi:application

[Install]
WantedBy=multi-user.target
```

Чтобы точно узнать путь до gunicorn (или любого другого приложения), активируйте виртуальное окружение и воспользуйтесь командой which:

```
which gunicorn 
```
Чтобы увидеть состояние всех запущенных юнитов используйте ```sudo systemctl```.

Запустите юнит gunicorn:

```
sudo systemctl start gunicorn # запустить юнит 
```
Дополнительной командой добавьте юнит gunicorn в список автозапуска операционной системы:
```
sudo systemctl enable gunicorn # добавить юнит в список автозапуска операционной системы 
```
Узнать статус юнита можно по следующей команде
```
sudo systemctl status gunicorn 
```

После любого изменения конфига gunicorn сперва необходимо выполнить ```sudo systemctl stop gunicorn.service``` и перезапустить демон ```sudo daemon-reload``` и после можно запустить юнит.

Теперь Gunicorn будет работать постоянно: он запустится при старте операционной системы в облаке, автоматически перезапустится при возникновении проблем, а управлять им теперь можно командами sudo systemctl start/stop/restart

## Настройка контейнера postqresql
Выполните устновку пакета postgresql:
```
sudo apt update 
sudo apt install postgresql postgresql-contrib -y 
```
После установки пакетов в операционной системе будет автоматически создан пользователь postgres, который имеет все права для работы с PostgreSQL: от его имени запускаются все процессы, обслуживающие базу данных, и ему принадлежат все файлы, относящиеся к ней. 
Управлять сервером базы данных можно стандартными командами systemd:

```
sudo systemctl stop postgresql # Остановить 
sudo systemctl start postgresql # Запустить
sudo systemctl restart postgresql # Перезапустить
sudo systemctl status postgresql # Узнать статус, текущее состояние
```
Файлы базы данных хранятся в директории /etc/postgresl/12/main/.
В ней же расположены два конфигурационных файла, которые определяют настройки сервера базы данных: это postgresql.conf и pg_hba.conf:
postgres.conf содержит настройки сервера базы данных;
pg_hba.conf определяет настройки доступа к БД, доступ к этому файлу разрешён только пользователю системы, имя которого совпадает с именем пользователя базы данных.
Чтобы проверить, что установка прошла успешно, запустите такую команду:
```
sudo -u postgres psql -c 'select now()' 
```
В ответ вы получите текущее время в формате UTC. now() — это встроенная функция PostgreSQL, которая возвращает текущее время. Её успешный вызов говорит о том, что всё работает.

### Управление базой через psql

В командной строке от имени пользователя postgres вызовите утилиту psql, это программа-клиент для подключения и управления СУБД:

```
sudo -u postgres psql
```

Чтобы посмотреть список текущих БД используйте команду ```\l```.
Чтобы выйти из режима просмотра списка баз, выполните команду ```\q```.

Теперь через psql создайте базу данных:
```
CREATE DATABASE <название БД проекта>;
```
Для взаимодействия с базой данных ваш Django-проект будет обращаться с запросами к серверу PostgreSQL. Для этого Django должен иметь право доступа на этот сервер, «быть залогиненным».

На сервере БД создайте регистрационную запись пользователя, затем данные этого пользователя (его логин и пароль) сообщите Django. В результате Django получит доступ к базе данных под этим именем:
```
-- Создайте пользователя user и придумайте свой пароль:
CREATE USER <user> WITH ENCRYPTED PASSWORD '<password>'; 
```

```
-- выдайте своему пользователю все права при работе с БД:
GRANT ALL PRIVILEGES ON DATABASE yatube TO <user>;  
```
Подключение к Django
База данных и пользователь готовы, теперь нужно дать Django-проекту доступ к этой базе.
Установите в виртуальное окружение драйвер для работы с postgres — psycopg2-binary:

Выйдите из psql с помощью команды \q. Далее выполните команду exit, чтобы прекратить работу под пользователем postgres и снова оказаться под своим пользователем.


Установите в виртуальное окружение драйвер для работы с postgres — psycopg2-binary:

```
pip install psycopg2-binary==2.8.6 
```
Секретные данные (токены, пароли, ключи) обычно хранятся отдельно от кода — в файлах конфигурации .env, именно туда записываются переменные окружения. Для работы с ними понадобится пакет python-dotenv. Установите его:
```
pip install python-dotenv 
```
Добавьте настройки в файл settings.py:
```
# ...директория_проекта/yatube/yatube/settings.py
from dotenv import load_dotenv

load_dotenv()

...

DATABASES = {
    'default': {
        'ENGINE': os.getenv('DB_ENGINE', 'django.db.backends.postgresql'),
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('POSTGRES_USER'),
        'PASSWORD': os.getenv('POSTGRES_PASSWORD'),
        'HOST': os.getenv('DB_HOST'),
        'PORT': os.getenv('DB_PORT')
    }
}
```

Данные параметры лучше хранить в отдельном файле .env, но из-за проблем использования сервиса gunicorn и load_dotenv() и данные указаны напряммую в настройках.
Теперь в директории с кодом проекта (там же, где размещены файлы settings.py и wsgi.py) создайте файл .env, откройте его в текстовом редакторе nano и добавьте настройки подключения к базе данных:
```
# ...директория_проекта/yatube/yatube/.env
# Укажите, что используете postgresql
DB_ENGINE=django.db.backends.postgresql
# Укажите имя созданной базы данных
DB_NAME=yatube
# Укажите имя пользователя
POSTGRES_USER=yatube_user
# Укажите пароль для пользователя
POSTGRES_PASSWORD=xxxyyyzzz
# Укажите localhost
DB_HOST=127.0.0.1
# Укажите порт для подключения к базе
DB_PORT=5432
```
выполните миграцию (должно быть активировано виртуальное окружение):
```
python manage.py migrate 
```
В моем случае пришлось указывать вме параметры DATABASE из settings.py напрямую, из-за проблемы взаимодействия gunicorn и load_dotenv():
```
DATABASES = {
    'default': {
        'ENGINE': os.getenv('DB_ENGINE', 'django.db.backends.postgresql'),
        'NAME': os.getenv('ваша БД'),
        'USER': os.getenv('user'),
        'PASSWORD': os.getenv('пароль от user'),
        'HOST': os.getenv('db'),
        'PORT': os.getenv('5432')
    }
} 
```

## Настройка контейнера nginx

Django-проект работает на порте 8000, и если отправить на сервер запрос без указания порта — сервер не ответит. Всё из-за того, что, если в HTTP-запросе порт не указан явно — он по умолчанию направляется на порт 80.
Решить эту проблему можно так: по внутренней сети перенаправить запрос с 80 порта на 8000. Именно от этого порта ждёт запросов ваше веб-приложение. 
Именно для этой задачи и необходимо настроить nginx.
На nginx не получится создать сервер с какой-то сложной логикой, он умеет раздавать только статические файлы. Поэтому nginx должен работать в связке с другим веб-сервером, который отвечает за логику. В данном случае этим веб-сервисом и будет выступать gunicorn.

Зайдите на удалённый сервер и из любой директории выполните команду:
```
sudo apt install nginx -y
```
Разрешите запросы по протоколам HTTP, HTTPS и SSH, выполнив команды:
```
sudo ufw allow 'Nginx Full'
sudo ufw allow OpenSSH 
```
Команда ```sudo ufw allow 'Nginx Full'``` разрешит принимать запросы на порты — 80 и 443: на них по умолчанию приходят запросы по HTTP и HTTPS.
Команда ```sudo ufw allow OpenSSH``` открывает порт 22 — это стандартный порт для соединения по SSH. Если этот порт не открыть, то после запуска файрвола доступ по SSH будет заблокирован: замок защёлкнется, а ключ останется внутри.
Теперь включите файрвол:
```
sudo ufw enable
```
Проверьте внесённые изменения:
```
sudo ufw status
```
ufw сообщит вам, что у него всё в порядке и доложит об открытых портах.

Из директории с manage.py выполните команду:
```
python manage.py collectstatic 
```

Вся статика будет собрана в директорию static/. 
Вы измените содержимое файла настроек проекта, и после сбора статики структура проекта изменилась. Но сервер Gunicorn об этом ещё ничего не знает и отображает сайт по-старому. Чтобы это исправить, сервер нужно перезапустить:
```
# Перезапустить все службы
sudo systemctl daemon-reload 
# Запустить демона gunicorn после перезапуска
sudo systemctl restart gunicorn
# Убедиться что gunicorn активен
sudo systemctl status gunicorn 
```

### Настройка nginx

В проекте храниться директория nginx/default.conf
Измените в нем адрес вашего ip сервера в поле server_name.

Протестируйте работоспособность новой конфигурации — нет ли синтаксических ошибок в конфиге. Даже из-за маленькой опечатки после перезапуска всё упадет. За такую проверку в утилите nginx отвечает ключ -t. Выполните команду:
```
sudo nginx -t

# текст успешной проверки:
# nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
# nginx: configuration file /etc/nginx/nginx.conf test is successful 
```

Если ошибок нет, перезапустите nginx, чтобы конфигурация вступила в силу. Это можно сделать двумя способами — командой restart или reload. Лучше использовать reload: эта команда проверит конфигурацию, дождётся окончания обработки всех запросов, и после этого мягко перезагрузит сервер.
```
sudo systemctl reload nginx 
```

Конфиг nginx должен принимать следующий вид:

```
server {
    # Слушаем порт 80
    listen 80;

    # Список IP, запросы к которым должен обрабатывать nginx
    # В этом уроке проект разворачивается локально, поэтому nginx
    # должен обрабатывать запросы к 127.0.0.1.
    # Если вы планируете разворачивать контейнеры на удалённом сервере,
    # здесь должен быть указан IP или доменное имя этого сервера
    server_name 127.0.0.1;

    # Указываем директорию со статикой:
    # если запрос направлен к внутреннему адресу /static/ — 
    # nginx отдаст файлы из /var/html/static/
    location /static/ {
        root /var/html/;
    }

    # Указываем директорию с медиа: 
    # если запрос направлен к внутреннему адресу /media/,
    # nginx будет обращаться за файлами в свою директорию /var/html/media/
    location /media/ {
        root /var/html/;
    }

    # Все остальные запросы перенаправляем в Django-приложение,
    # на порт 8000 контейнера web
    location / {
        proxy_pass http://web:8000;
    }
} 
```
По умолчанию все HTTP-запросы приходят на 80-й порт сервера. В запросе этот порт не прописывается в явном виде. В строке listen 80 серверу nginx указано обрабатывать запросы, полученные на порт 80.
##### Настройки ```location /static/``` и ```location /media/```
В конфиге указано, из какой директории nginx должен раздавать статику и медиа: запросы к адресу /static/ будут перенаправлены в директорию /var/html/static/, а запросы к адресу /media/ — в /var/html/media/.
##### Настройка location /
В свою очередь Django-приложение ожидает запросы на порт 8000. Следовательно, nginx должен принимать запросы на 80 порте и перенаправлять их на 8000 порт в контейнер web. 
Для Django указаны следующие настройки в settings.py:
```
STATIC_URL = '/static/'
# STATICFILES_DIRS = (os.path.join(BASE_DIR, 'static/'),) 
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
```
В docker-compose уже прописан код, который соберет контейнер для nginx.

## Запуск docker-compose

Для сборки и запуска проекта выполните следующую команду (вы должны находиться в директории проекта с файлом manage.py):

```
docker-compose up -d --build 
```
Для пересборки команда up выполняется с параметром --build.
Чтобы логи не мешали управлять контейнерами через терминал, развёртывание контейнеров выполняется в «фоновом режиме»: для этого применяется ключ -d.

В контейнере web нужно выполнить миграции, создать суперпользователя и собрать статику. Команды внутри контейнеров выполняют посредством подкоманды docker-compose exec. Это эквивалент docker exec: с её помощью можно выполнять произвольные команды в сервисах внутри контейнеров.
Выполните по очереди команды:
```
docker-compose exec web python manage.py migrate
docker-compose exec web python manage.py createsuperuser
docker-compose exec web python manage.py collectstatic --no-input 
```
После этого все контейнеры полнимуться и можно будет войти в веб приложение вне виртуальной машины linux.
Для работы с другими контейнерами, собранные контейнеры можно остановить следующей командой:
```
docker-compose down -v 
```

